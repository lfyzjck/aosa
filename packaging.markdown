---
layout: default
title: Python Packaging
---

# [Dirkjan Ochtman](packaging.html#Tarek-Ziadé)


### 14.1 简介
对于软件的安装现在有两种学派。第一种，是像Windows和Mac OS X那样，应用程序是自给自足的，它们安装时不依赖于其他任何东西。这种简化应用程序管理的哲学就是：每个应用程序都是独立的，它的安装和删除不会影响操作系统。如果应用程序需要一些非公用库，那么这些库应该包含在软件的发行包当中。

第二种学派是以基于Linux的系统为标准，他们认为软件是很多被叫做包（Package）的自足的小单元的集合。软件需要的库会被捆绑到包当中，任何给定的包都可能依赖于其他的包。安装一个软件可能就是寻找并安装很多特定版本的其他库。这些依赖的库通常会从一个包含数以千计包的中央仓库中获得。这样就解释了为什么Linux发行版需要像dpkg或者RPM这样复杂的包管理系统来跟踪包之间的依赖关系以及阻止应用程序使用同一个库的两个不兼容版本。

每种方法都各有利弊。一个高度模块化的系统能够使系统管理更加轻松方便，因为系统的每一部分都可以被更新或者替换，每个库都存在于一个单独的地方，当这些库被升级的时候，所有使用这些库的应用程序都能享受到升级带来的好处。例如，一个针对特定库的安全补丁能够立即影响到所有使用它的应用程序，反之如果每个应用都附带自己的库，尤其当不同的程序使用该库的不同版本时，那么这个安全补丁将变得更加难以部署。

不过模块化被一些开发人员认为是缺点，因为他们不能控制他们的应用程序及其依赖的库。对他们来说，提供一套独立的软件设备来保证应用环境的稳定并且不会在系统升级时陷入“依赖地狱”（原文是dependency hell）显得更为轻松一些。

当软件需要支持多个操作系统的时候，自给自足的应用程序也会让程序员好过很多。一些项目甚至会发布所谓的绿色程序，它们会消除一切与操作系统的互动甚至是日志文件，然后工作在一个自足的目录下。

Python的包系统是计划遵循第二种哲学--每个安装都需要多种依赖--尽可能的方便开发者，方便管理，对用户友好。不幸的是它还有很多缺陷并且导致了各种各样的问题：与直觉违背的版本计划、无法处理的数据文件、难以重新打包等等。三年前我和一些其他的Python开发者决定改造它来解决这些问题。我们称我们自己为“The Followship of the Packaging”，这一章就会描述我们曾经尝试去修复的问题以及我们的解决方案。

> #### 术语
> 在Python中，一个包就是包含很多Python文件的目录。这些文件被称为模块（modules）。这样的定义让“Package”这个词的用法有些含糊，因为它在很多系统中也被用来表示一个项目的发行。
> 
> 很多Python开发者自己也会混淆这个词的含义。消除这种歧义的方法之一就是当我们谈及Python的模块时，使用"Python packages"这个术语来代替。“releasa”被用来表示一个项目的一个版本，“distribution”表示某次发布的源代码或者二进制文件，比如tarball或者zip文件。

### Python开发者的负担
大部分程序员希望他们的程序能够在所有环境下运行。他们也经常会混合使用一些标准的Python库和系统相关的库
