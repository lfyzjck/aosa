---
layout: default
title: Mercurial
---

# Dirkjan Ochtman


Mercurial是一个现代的分布式版本控制软件（VCS），主要用Python编写，少部分为提高性能采用C编写。在这一章，我将讨论与设计Mercurial算法和数据结构相关的一些选择。首先，让我简单介绍一下版本控制系统的历史，来引入必要的背景。



## 版本控制简史

尽管本章主要讨论Mercurial的软件架构，很多概念和别的版本控制系统是相同。为了更好地讨论Mercurial，首先，我来举一些版本控制系统的概念和功能的名称。To put all of this in perspective, 我也将简单地介绍这个领域的历史。


版本控制系统设计用来帮助开发人员同时开发同一个软件系统。没有版本控制系统，开发人员只能相互交换完整的拷贝，并自行维护文件修改记录。我们用文件树来抽象软件的源代码。版本控制的一个主要功能就是分发文件树的变更。一个基本的周期就像这样：


   1. 从别人那里获取最新的文件树
   2. 对这个版本的文件树作一组变更
   3. 发布变更，这样别人就可以获取到了


第一个功能，得到本地文件树，叫做签出。存储我们获取、提交的变更的叫仓库，而签出的结果叫工作目录、工作树或工作拷贝。从仓库的最新文件更新本地拷贝就叫更新，有时候这需要合并，即合并不同用户对同一文件的修改。你可以用diff命令来检查一个文件树或者文件的两次修订之间的变更情况。最常用来检查你的工作拷贝里的本地（未发布的）变更。用提交命令可以发布变更，这会把工作目录中的变更保存到仓库。



### 集中式版本控制


第一个版本控制系统是Source Code Control System, SCCS。在1975年第一次有人论述它。它主要是提出了一种保存单个文件的更改的方法，这种方法比保存多个拷贝更加经济。它并不能帮你向别人发布这些变更。1982年出现了Revision Control System，RCS。这是一个更加成熟并且自由的SCCS替代品（GNU工程仍在维护它）。


在RCS之后是CVS，协作版本系统，在1986年第一次发布的时候，是一组脚本，用来按组操作RCS修订的文件。CVS的大革新是认为若干用户可以同时编辑，在编辑之后进行合并。这就需要能编辑冲突。开发人员只能提交基于仓库最新可用版本的文件。如果在仓库和我的工作目录同时有变更，我需要解决这些变更带来的冲突（编辑同时变更的行）。


CVS对分支和标签的看法也是很先进的。CVS的分支允许开发者同时在不同的文件上工作，CVS的标签可以给一个稳定的快照命名以方便引用。最初CVS只能通过在共享文件系统上的仓库交换更改，后来又实现了用于在大型网络（如互联网）交换的主从架构。


在2000年，三个开发者聚到一起开发一个新的版本控制系统，叫做Subversion，企图弥补CVS的一些主要缺陷。最重要的，Subversion每次操作都是针对整棵树的，这意味着每次修订的变更都必须具有原子性、一致性、独立性、持久性。Subversion工作拷贝同时也维护一个在工作目录签出的修订的干净版本。于是，一个常见的diff操作（把本地树和一个签出的变更集进行比较）是在本地进行的，因此会比较快。


Subversion有一个有意思的概念，标签和分支都是项目树的一部分。一个Subversion项目通常分成三个部分：标签，分支和主干。这样的设计非常符合不熟悉版本控制系统的用户的直觉，尽管这种设计固有的灵活性对转换工具造成了不计其数的困难，主要就是因为标签和分支在别的系统中具有更结构化的表示。


上述系统都被认为是集中式的，即便（从CVS开始）它们可以交换变更，它们还是依赖另一台计算机来维护仓库的历史。而分布式版本控制系统在每个有工作目录的计算机上都有仓库的全部或者部分历史的一份拷贝。


### 分布式版本控制


## 数据结构





